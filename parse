#! /usr/bin/env python

from __future__ import print_function, division, unicode_literals


import sys
import subprocess
import json
import code
import inspect
import cStringIO as StringIO
import os.path
import shutil
import pygments, pygments.lexers, pygments.formatters
import urllib
import hashlib
import traceback


# TEMPORARY HACK
def input_wrapper( *args ):
    raise NotImplementedError
def raw_input_wrapper( *args ):
    raise NotImplementedError
import __builtin__
__builtin__.input = input_wrapper
__builtin__.raw_input = raw_input_wrapper
# END TEMPORARY HACK


def escape_html( s ):

    return reduce( lambda t, a: t.replace( *a ), ( ('&','&amp;'), ('<','&lt;'), ('>','&gt;'), ('"','&quot;') ), s )

def escape_url( url ):

    return urllib.quote( url )


class HtmlFormatter( pygments.formatters.HtmlFormatter ):

    def wrap( self, source, outfile ):

        return self._wrap_code( source )

    def _wrap_code( self, source ):

        lineno = 0
        for i, t in source:
            if i == 1:
                lineno += 1
                if t.endswith( '\r\n' ):
                    t, end = t[ :-2 ], t[ -2: ]
                elif t.endswith( '\n' ):
                    t, end = t[ :-1 ], t[ -1: ]
                t = '<div class="line lineno{}">{}</div>{}'.format( lineno, t, end )
            yield i, t


class HtmlFormatterIC( pygments.formatters.HtmlFormatter ):

    def wrap( self, source, outfile ):

        return self._wrap_code( source )

    def _wrap_code( self, source ):

        for i, t in source:
            if i == 1:
                if t.endswith( '\r\n' ):
                    t, end = t[ :-2 ], t[ -2: ]
                elif t.endswith( '\n' ):
                    t, end = t[ :-1 ], t[ -1: ]
                if t.startswith( '<span class="gp">... </span>' ) or t.startswith( '<span class="gp">&gt;&gt;&gt; </span>' ):
                    cls = 'code'
                else:
                    cls = 'output'
                t = '<div class="line {}">{}</div>{}'.format( cls, t, end )
            yield i, t


class IC( code.InteractiveConsole ):

    def __init__( self, prefix ):

        self.prefix = prefix

        self._locals = { '__name__' : '__console__', '__doc__' : None }

        self.prompt = False
        code.InteractiveConsole.__init__( self, self._locals )

        self._locals[ 'init_console' ] = self._init_console
        self.push_hidden( 'init_console()' )
        del self._locals[ 'init_console' ]

        self._pending_figures = []
        self.fignum = 0

    @property
    def pending_figures( self ):

        return self._pending_figures_iterator()

    def _pending_figures_iterator( self ):

        while self._pending_figures:
            yield self._pending_figures.pop( 0 )

    def push( self, line ):

        print( '...' if self.prompt else '>>>', line )
        self.prompt = code.InteractiveConsole.push( self, line )
        return self.prompt

    def push_hidden( self, line ):

        self.prompt = code.InteractiveConsole.push( self, line )
        return self.prompt

    def write( self, line ):

        print( line, end = '' )

    def _init_console( self ):

        import sys
        sys.path.append( '.' )

        import matplotlib
        matplotlib.use( 'cairo' )
        import matplotlib.pyplot

        def return_None_wrapper( func ):

            def wrapped( *args, **kargs ):
                func( *args, **kargs )

            return wrapped

        for attr in ( 'plot', 'title', 'xlabel', 'ylabel', 'subplot', 'imshow' ):
            setattr( matplotlib.pyplot, attr, return_None_wrapper( getattr( matplotlib.pyplot, attr ) ) )

        def show_wrapper():

            figures=[manager.canvas.figure for manager in matplotlib._pylab_helpers.Gcf.get_all_fig_managers()]
            for figure in figures:
                name = '{}_matplotlib_{:04d}'.format( self.prefix, self.fignum )
                figure.savefig( name + '.svg' )
                figure.savefig( name + '.pdf' )
                matplotlib.pyplot.close( figure )
                self.fignum += 1
                self._pending_figures.append( name )

        matplotlib.pyplot.show = show_wrapper


class Debugger:

    def __init__( self, code, globals = None, locals = None ):

        if globals is None:
            globals = {}
        if locals is None:
            locals = globals

        self._code = code
        self._globals = globals
        self._locals = locals

    def run( self ):

        self.items = []
        self._console = StringIO.StringIO()

        self._calling_frame = inspect.currentframe()
        self._code_filename = self._code.co_filename

        # capture stdout, stderr
        orig_stdout = sys.stdout
        orig_stderr = sys.stderr
        try:
            try:
                sys.stdout = self._console
                sys.stderr = self._console

                sys.settrace( self._trace_callback )
                exec( self._code, self._globals, self._locals )
            finally:
                sys.settrace( None )
                sys.stdout = orig_stdout
                sys.stderr = orig_stderr
        except:
            print( self._last_exception_string, end = '', file = self._console )
            self._append_item( 'script exited with exception', None, None )

    def _trace_callback( self, frame, event, arg ):

        if event == 'line':
            if frame.f_code.co_filename != self._code_filename:
                # disable trace for this frame
                return
            self._append_item( 'line', frame, None )
        elif event == 'call':
            self._append_item( 'call', frame, None )
            if frame.f_code.co_filename != self._code_filename:
                # disable trace for this function
                return
        elif event == 'return':
            self._append_item( 'return', frame, 'return value: {!r}'.format( arg ) )
        elif event == 'exception':
            self._last_exception_string = ''.join( traceback.format_exception( *arg ) )
            self._append_item( 'exception', frame, self._last_exception_string )
#       elif event == 'c_call':
#           pass
#       elif event == 'c_exception':
#           pass
#       elif event == 'c_return':
#           pass

        return self._trace_callback

    def _append_item( self, event, frame, arg ):

        stack = StringIO.StringIO()
        print_stack = lambda *args, **kargs: print( *args, file = stack, **kargs )

        f = frame
        while f and f is not self._calling_frame:
            print_stack( 'File {!r}, line {}, in {}'.format( f.f_code.co_filename, f.f_lineno, f.f_code.co_name ) )
            if f.f_code.co_filename == self._code_filename:
                if f.f_globals is f.f_locals:
                    print_stack( '  locals, globals:' )
                    for k, v in sorted( f.f_locals.items() ):
                        if k.startswith( '_' ):
                            continue
                        print_stack( '    {}: {!r}'.format( k, v ) )
                else:
                    print_stack( '  locals:' )
                    for k, v in sorted( f.f_locals.items() ):
                        if k.startswith( '_' ):
                            continue
                        print_stack( '    {}: {!r}'.format( k, v ) )
                    print_stack( '  globals:' )
                    for k, v in sorted( f.f_globals.items() ):
                        if k.startswith( '_' ):
                            continue
                        print_stack( '    {}: {!r}'.format( k, v ) )
            f = f.f_back

        if frame:
            event = '{}, file {!r}, line {}, in {}'.format( event, frame.f_code.co_filename, frame.f_lineno, frame.f_code.co_name )
        if arg:
            event = '{}\n{}'.format( event, arg )
#       event = event, frame.f_code.co_filename, frame.f_lineno, frame.f_code.co_name, repr( arg )
        if frame and frame.f_code.co_filename == self._code_filename:
            line = frame.f_lineno
        else:
            line = None
        self.items.append( ( line, event, self._console.getvalue(), stack.getvalue() ) )


def convert_ast( doc, doc_name ):

#   python_lexer = pygments.lexers.get_lexer_by_name( 'python' )
    python_lexer = pygments.lexers.PythonLexer()
    python_console_lexer = pygments.lexers.PythonConsoleLexer()
#   html_formatter = pygments.formatters.get_formatter_by_name( 'html' )
    html_formatter = HtmlFormatter( linenos = False, cssclass = "pythoncode" )
    html_console_formatter = HtmlFormatterIC( linenos = False, cssclass = "pythoncode" )
    latex_formatter = pygments.formatters.LatexFormatter( linenos = False )


    ic = IC( prefix = doc_name )

    new_body = []

    def new_slide( slide_counter ):

        html_code = '<div id="slide-{}" class="slide"><div class="container">'.format( slide_counter )
        if slide_counter > 0:
            html_code = '</div></div>' + html_code
        new_body.append( { 'RawBlock' : [ 'html', html_code ] } )
        return slide_counter + 1

    slide_counter = new_slide( 0 )

    next_new_slide = False

    for item in doc[ 1 ]:

        if next_new_slide:
            slide_counter = new_slide( slide_counter )
            next_new_slide = False

            if item == 'HorizontalRule':
                continue

        if isinstance( item, dict ) and 'CodeBlock' in item and item[ 'CodeBlock' ][ 1 ].startswith( '>>>' ):

            default_output_hidden = False

            data = item[ 'CodeBlock' ]
            src = ( data[ 1 ] + '\n' ).splitlines()

            code_in_ic = 'interactive_console' in src[ 0 ] or 'ic' in src[ 0 ]
            code_in_debugger = 'debugger' in src[ 0 ]
            default_output_hidden = 'default_output_hidden' in src[ 0 ]

            src = src[ 1: ]

            if code_in_ic:

                # run `src` through an interpreter, and capture stdout
                original_stdout = sys.stdout
                original_stderr = sys.stderr
                sys.stderr = sys.stdout = StringIO.StringIO()
                more_input_required = False
                for line in src:
                    more_input_required = ic.push( line )
                # push a blank line if more input is required, but the code block has ended
                if more_input_required:
                    ic.push( '' )
                output = sys.stdout.getvalue()
                sys.stdout = original_stdout
                sys.stderr = original_stderr

                # highlighting of src and output
                code_html = pygments.highlight( output, python_console_lexer, html_console_formatter )
                code_latex = pygments.highlight( output, python_console_lexer, latex_formatter )

            elif code_in_debugger:

                try:
                    c = compile( '\n'.join( src ), mode = 'exec', filename = '<script>', dont_inherit = True )
                except:
                    c = None
                else:
                    db = Debugger( c )
                    db.run()

                    json_data = json.dumps( db.items )
                    json_hash = hashlib.sha1( json_data ).hexdigest()
                    json_filename = 'debug_{}.json'.format( json_hash )
                    with open( json_filename, 'w' ) as debug_info:
                        debug_info.write( json_data )

                # highlighting of src
                code_html = pygments.highlight( '\n'.join( src ), python_lexer, html_formatter )
                code_latex = pygments.highlight( '\n'.join( src ), python_lexer, latex_formatter )

                if c is not None:
                    code_html = '<a href="{}" class="debugger_data_url">debugger_data_url</a>{}'.format( escape_url( json_filename ), code_html )

            else:

                # highlighting of src
                code_html = pygments.highlight( '\n'.join( src ), python_lexer, html_formatter )
                code_latex = pygments.highlight( '\n'.join( src ), python_lexer, latex_formatter )

            classes = [ 'pythoncode' ]
            if code_in_ic:
                classes.append( 'interactive_console' )
            if code_in_debugger:
                classes.append( 'debugger' )
            if default_output_hidden:
                classes.append( 'output_hidden' )
            classes = ' '.join( classes )
            code_html = '<div class="{}"><div class="container">\n{}\n</div></div>'.format( classes, code_html )

            if 'hidden' not in data[ 0 ][ 1 ]:

                new_body.append( { 'RawBlock' : [ 'html', code_html ] } )
                new_body.append( { 'RawBlock' : [ 'latex', code_latex ] } )

            for figure in ic.pending_figures:
                slide_counter = new_slide( slide_counter )
                next_new_slide = True
                code_html = '<div class="output image"><img src="{}.svg"/></div>'.format( figure )
                #code_html = '<div class="output image"><object data="{}.svg" type="image/svg+xml"></object></div>'.format( figure )
                code_latex = '\\includegraphics[width=.75\\textwidth]{{{}}}'.format( figure )
                new_body.append( { 'RawBlock' : [ 'html', code_html ] } )
                new_body.append( { 'RawBlock' : [ 'latex', code_latex ] } )

        elif item == 'HorizontalRule':

            slide_counter = new_slide( slide_counter )

        else:

            new_body.append( item )

    new_body.append( { 'RawBlock' : [ 'html', '</div></div>' ] } )

    return doc[ 0 ], new_body


if __name__ == '__main__':

    src = sys.argv[ 1 ]
    name, ext = os.path.splitext( src )
    if not os.path.isfile( src ):
        print( 'No such file: {}'.format( src ) )
        raise SystemExit

    pandoc = subprocess.Popen( [ 'pandoc', '-t', 'json', src ], stdout = subprocess.PIPE )
    doc, tmp = pandoc.communicate()
    doc = json.loads( doc )

    root = os.path.split( __file__ )[ 0 ]
    p = lambda f: os.path.join( root, f )

    doc = json.dumps( convert_ast( doc, name ) )
    pandoc = subprocess.Popen( [ 'pandoc', '-f', 'json', '-t', 'html', '--standalone', '--mathjax=http://cdn.mathjax.org/mathjax/2.2-beta/MathJax.js?config=TeX-AMS-MML_HTMLorMML', '--css=pygments.css', '--css=slideshow.css', '--include-in-header', p( 'html_include' ), '--output', name + '.xhtml' ], stdin = subprocess.PIPE )
    pandoc.communicate( doc )
#   pandoc = subprocess.Popen( [ 'pandoc', '-f', 'json', '-t', 'latex', '--standalone', '--include-in-header', p( 'tex_include' ), '--include-in-header', p( 'pygments.tex' ), '--output', name + '.tex' ], stdin = subprocess.PIPE )
#   pandoc.communicate( doc )

    for f in ( 'slideshow.css', 'slideshow.js', 'pygments.css' ):
        if not os.path.exists( f ):
            shutil.copy( p( f ), f )
